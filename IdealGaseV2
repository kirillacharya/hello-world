
#include "TXLib.h"
#define GAKS GetAsyncKeyState

//-----------------------------------------------------------------------------

const double PERX = GetSystemMetrics (SM_CXSCREEN)*100/100/100, PERY = GetSystemMetrics (SM_CYSCREEN)*100/100/100;

const int LWX = 0, LWY = 0, RWX = PERX*40, RWY = PERY*100;

const int Size = 1000;

const double DT = 0.01;

//-----------------------------------------------------------------------------

struct SVector
    {
    double x, y;    //projections
    double cx, cy;  //centers
    };

//-----------------------------------------------------------------------------

class CBall
    {
    public:

    int r;
    int rNew;

    double x, y;

    SVector velocity;

    COLORREF SFcolor;
    COLORREF Scolor;

    double AllVelocity;

    CBall ();

    void DrawBall ();
    void BallPhysics ( double *PistonYU, double *PistonYD );
    };

//-----------------------------------------------------------------------------

class CManager
    {
    public:

    CBall Array [Size] = {};

    void MainCycle ();

    CManager ();

    void Collision  ();
    void ColPhysics ( int i, int j, SVector &NewPI, SVector &NewPJ );

    double Temperature, Pressure, Volume;

    double PistonWidth, PistonYU, PistonYD;

    COLORREF AllColor;

    private:

    int MomentSize;

    void VesselAndPiston ();
    void Table ();

    void AllBallsDraw ();
    void AllBallsPhysics ();
    void BounceCounter ();
    void SizePlus ();
    void SizeMinus  ();
    void Selection ();
    int Searcher ( int min, int i );
    void Swapper ( int a, int b );

    void AccurateColTime ( int i, int j );

    void CTemperature ();
    void CPressure ();

    void VelPlus();
    void VelMinus();

    double AverageVelocitySquared ();
    };

//-----------------------------------------------------------------------------

void Title                ( int X1, int Y1, int X2, int Y2, COLORREF Tcolor );
double  Random            ( double min, int max );

double  VectScalarProduct ( SVector a, SVector b );
double  VectModule        ( SVector a );
double  Lenght            ( SVector a, SVector b );
SVector VectSum           ( SVector a, SVector b );
SVector VectSubsract      ( SVector a, SVector b );
SVector VectMult          ( SVector a, double Number );
SVector VectDivision      ( SVector a, double Number );
SVector VectNormalization ( SVector a );
SVector VectorDots        ( double cx1, double cy1, double cx2, double cy2 );

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

int main()
    {
    txCreateWindow ( PERX*100, PERY*100 );

    CManager Man1;

    Man1.MainCycle ();

    return 0;
    }

//{----------------------------------------------------------------------------
//! THE OPERATIONS WITH VECTORS
//}----------------------------------------------------------------------------

//-----------------------------------------------------------------------------

void DrawVector ( SVector a, COLORREF Color, int width, int Pause )
    {
    if ( Pause == 1 ) getch();                          //do you want to pause?
    txSetColor ( Color, width );
    txSetFillColor ( Color );
    txLine ( a.cx, a.cy, a.cx + a.x*0.01, a.cy + a.y*0.01 );
    txCircle (a.cx + a.x*0.01, a.cy + a.y*0.01, 5);
    }

//-----------------------------------------------------------------------------

SVector VectorDots ( double cx1, double cy1, double cx2, double cy2 )
    {
    SVector v;

    v.x = cx2 - cx1;
    v.y = cy2 - cy1;

    v.cx = cx1, v.cy = cy1;

    return v;
    }

//-----------------------------------------------------------------------------

double VectModule ( SVector a )
    {
    double module;

    module = sqrt (a.x*a.x + a.y*a.y);

    return module;
    }

//-----------------------------------------------------------------------------

double Lenght ( SVector a, SVector b )
    {
    double Lenght;

    Lenght = sqrt ((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));

    return Lenght;
    }
//-----------------------------------------------------------------------------

SVector VectNormalization ( SVector a )
    {
    SVector n;

    n = VectDivision ( a, VectModule(a) );

    return n;
    }

//-----------------------------------------------------------------------------

double VectScalarProduct ( SVector a, SVector b )
    {
    double result;

    result = a.x * b.x + a.y * b.y;

    return result;
    }

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

SVector VectSum ( SVector a, SVector b )
    {
    SVector v;

    v.x = a.x + b.x;
    v.y = a.y + b.y;

    return v;
    }

//-----------------------------------------------------------------------------

SVector VectSubsract ( SVector a, SVector b )
    {
    SVector v;

    v.x = a.x - b.x;
    v.y = a.y - b.y;

    return v;
    }

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

SVector VectMult ( SVector a, double Number )
    {
    SVector v;

    v.x = a.x*Number;
    v.y = a.y*Number;

    //v.cx = a.cx, v.cy = a.cy;

    return v;
    }

//-----------------------------------------------------------------------------

SVector VectDivision ( SVector a, double Number )
    {
    SVector v;

    v.x = a.x/Number;
    v.y = a.y/Number;

    return v;
    }

//{----------------------------------------------------------------------------
//! THE BALLS CLASS
//}----------------------------------------------------------------------------

CBall::CBall ():
    r               (PERX),
    rNew            (r),
    x               (Random(rNew, RWX - rNew)),
    y               (RWY - rNew),
    velocity        ({ Random(70, 150), Random(120, 150), x, y }),
    SFcolor         ( RGB (255, 0, 0) ),
    Scolor          (SFcolor),
    AllVelocity     ( velocity.x*velocity.x + velocity.y*velocity.y )
    {}

//-----------------------------------------------------------------------------

void CBall::DrawBall ()
    {
    txSetColor ( Scolor, 3 );
    txSetFillColor ( SFcolor );

    SVector P = VectMult ( velocity, r );
    P.cx = x, P.cy = y;

    txCircle ( x, y, rNew );
    }

//-----------------------------------------------------------------------------

void CBall::BallPhysics ( double *PistonYU, double *PistonYD )
    {
    x = x + velocity.x * DT;
    y = y + velocity.y * DT;

    if ( x >= RWX - rNew )
        {
        x = RWX - rNew;

        velocity.x = -velocity.x;
        }

    if ( y <= rNew )
        {
        y = rNew;

        velocity.y = -velocity.y;
        }

    if ( x <= rNew )
        {
        x = rNew;

        velocity.x = -velocity.x;
        }

    if ( y >= RWY - rNew )
        {
        y = txGetExtentY() - rNew;

        velocity.y = -velocity.y;
        }

    /*if ( y + rNew >= *PistonYU )
        {
        y = *PistonYU - rNew;

        velocity.y = -velocity.y;
        }   */

    if ( y - rNew <= *PistonYD )
        {
        y = *PistonYD + rNew;

        velocity.y = -velocity.y;
        }

    }


//-----------------------------------------------------------------------------

void CManager::VelPlus()
    {
    for ( int i = 0; i < MomentSize; i++ )
        {
        if (Array[i].velocity.x >= 0) Array[i].velocity.x += 2;
        else Array[i].velocity.x -= 2;

        if (Array[i].velocity.y >= 0) Array[i].velocity.y += 2;
        else Array[i].velocity.y -= 2;
        }
    }

//-----------------------------------------------------------------------------

void CManager::VelMinus()
    {
    for ( int i = 0; i < MomentSize; i++ )
        {
        if (Array[i].velocity.x >= 0) Array[i].velocity.x -= 2;
        else Array[i].velocity.x += 2;

        if (Array[i].velocity.y >= 0) Array[i].velocity.y -= 2;
        else Array[i].velocity.y += 2;
        }
    }

//-----------------------------------------------------------------------------

CManager::CManager ():

    Array ({}),
    Temperature (0),
    Pressure (0),
    Volume(0),
    PistonWidth(PERY*10),
    PistonYU (PERY*30),
    PistonYD (PistonYU + PistonWidth),
    AllColor  (RGB ( 0, 255, 255 )),
    MomentSize (10)
    {}

//-----------------------------------------------------------------------------

void CManager::ColPhysics ( int i, int j, SVector &NewVI, SVector &NewVJ )
    {
    //The Mechanism Of Collision [+Graphical Results]   P.S. Not Call Physics!

    SVector Centres, NewN/*, NewT*/;                     //the basis vector n
    SVector PI, PJ, NewPI, NewPJ;                        //vectors of old and impulses
    SVector NewPIN, NewPJN, PIT, PJT, VectPIN, VectPJN;  //new, old projections(vectors), vectors OY
    double PIN, PJN;                                     //projections of impulses on axis
    int width = 5;

    PI = VectMult ( Array[i].velocity, Array[i].r );     //the vectors of impulses
    PJ = VectMult ( Array[j].velocity, Array[j].r );     //---//---

    PI.cx = Array[i].x, PI.cy = Array[i].y;              //the centers of those vectors
    PJ.cx = Array[j].x, PJ.cy = Array[j].y;              //---//---

    Centres = VectorDots ( Array[i].x, Array[i].y, Array[j].x, Array[j].y ); //the vector of centers

    NewN = VectNormalization ( Centres );                //the Basis Vector

    PIN = VectScalarProduct (PI, NewN);                  //Projections on Basis
    PJN = VectScalarProduct (PJ, NewN);                  //---//---

    VectPIN = VectMult (NewN, PIN);                      //Vector of projections
    VectPJN = VectMult (NewN, PJN);                      //---//---
    VectPIN.cx = Array[i].x, VectPIN.cy = Array[i].y;
    VectPJN.cx = Array[j].x, VectPJN.cy = Array[j].y;

    PIT = VectSubsract ( PI, VectPIN );                  //Vector of projection on OY(OT)
    PJT = VectSubsract ( PJ, VectPJN );                  //---//---
    PIT.cx = Array[i].x, PIT.cy = Array[i].y;
    PJT.cx = Array[j].x, PJT.cy = Array[j].y;

    std::swap ( PIN, PJN );                              //swap of the vector projections on X

    NewPIN = VectMult ( NewN, PIN );                     //New Projection Vector
    NewPJN = VectMult ( NewN, PJN );                     //---//---
    NewPIN.cx = Array[i].x, NewPIN.cy = Array[i].y;
    NewPJN.cx = Array[j].x, NewPJN.cy = Array[j].y;

    NewPI = VectSum ( NewPIN, PIT );                     //New impulses
    NewPJ = VectSum ( NewPJN, PJT );                     //---//---
    NewPI.cx = Array[i].x, NewPI.cy = Array[i].y;
    NewPJ.cx = Array[j].x, NewPJ.cy = Array[j].y;

    NewVI = VectDivision ( NewPI,  Array[i].r );         //reabilitation of velocities
    NewVJ = VectDivision ( NewPJ,  Array[j].r );         //---//---
    }

//-----------------------------------------------------------------------------

void CManager::MainCycle ()
    {
    while ( !GAKS(VK_ESCAPE) )
        {
        txSetFillColor ( TX_BLACK );
        txClear();

        VesselAndPiston ();
        Table ();

        CTemperature ();
        CPressure ();

        if ( GAKS ( 'A' ) )      SizePlus ();
        if ( GAKS ( 46 ) )       SizeMinus ();

        if ( GAKS ( 'W' ) )      VelPlus();
        if ( GAKS ( 'S' ) )      VelMinus();


        AllBallsDraw ();
        AllBallsPhysics ();

        Collision();

        txSleep(10);
        //txClear();
        }

    }

//-----------------------------------------------------------------------------

void CManager::AllBallsDraw ()
    {
    for ( int i = 0; i < MomentSize; i++ )
        Array[i].DrawBall();
    }

//-----------------------------------------------------------------------------

void CManager::AllBallsPhysics ()
    {
    for ( int i = 0; i < MomentSize; i++ )
        Array[i].BallPhysics( &PistonYU, &PistonYD );
    }

//-----------------------------------------------------------------------------

void CManager::Collision ()
    {
    for ( int i = 0; i < MomentSize; i++ )
        {
        for ( int j = i + 1; j < MomentSize; j++ )
            {
            AccurateColTime ( i, j );
            }
        }
    }

//-----------------------------------------------------------------------------

void CManager::AccurateColTime ( int i, int j )
    {
    SVector NewVI, NewVJ;
    double T;

    double dx = (Array[j].x - Array[i].x), dy = (Array[j].y - Array[i].y);
    double dvx = (Array[j].velocity.x - Array[i].velocity.x), dvy = (Array[j].velocity.y - Array[i].velocity.y);

    double R = Array[i].r + Array[j].r;

    double Disc = ((dx*dvx + dy*dvy)*(dx*dvx + dy*dvy) - (dvx*dvx + dvy*dvy)*(dx*dx + dy*dy - R*R));

    if (Disc >= 0)
        {
        double sqrtDisc = sqrt(Disc);

        double T1 = (-(dx*dvx + dy*dvy) + sqrtDisc)/(dvx*dvx + dvy*dvy);
        double T2 = (-(dx*dvx + dy*dvy) - sqrtDisc)/(dvx*dvx + dvy*dvy);

        if ( T1 < T2 ) T = T1;
        else T = T2;

        if ( T < DT && T > 0 )
            {
            Array[i].x = Array[i].x + Array[i].velocity.x*T;
            Array[i].y = Array[i].y + Array[i].velocity.y*T;

            Array[j].x = Array[j].x + Array[j].velocity.x*T;
            Array[j].y = Array[j].y + Array[j].velocity.y*T;

            ColPhysics ( i, j, NewVI, NewVJ );

            Array[i].velocity = NewVI;
            Array[j].velocity = NewVJ;

            Array[i].x = Array[i].x + Array[i].velocity.x*(DT-T);
            Array[i].y = Array[i].y + Array[i].velocity.y*(DT-T);

            Array[j].x = Array[j].x + Array[j].velocity.x*(DT-T);
            Array[j].y = Array[j].y + Array[j].velocity.y*(DT-T);
            }
        }
    }

//{----------------------------------------------------------------------------
//!  IDEAL GASE CALCULATIONS
//}----------------------------------------------------------------------------


//-----------------------------------------------------------------------------

double CManager::AverageVelocitySquared ()
    {
    double VelocitySum = 0, VelocitySum0 = 0, AverageVelocity = 0;
    for ( int i = 0; i < MomentSize; i++ )
        {
        Array[i].AllVelocity = (Array[i].velocity.x*Array[i].velocity.x + Array[i].velocity.y*Array[i].velocity.y );
        VelocitySum = VelocitySum0 + Array[i].AllVelocity;
        VelocitySum0 = VelocitySum;
        }

    assert ( MomentSize > 0 );

    AverageVelocity = VelocitySum0/MomentSize;

    return AverageVelocity;
    }

//-----------------------------------------------------------------------------

void CManager::CTemperature ()
    {
    Temperature = AverageVelocitySquared() * ( 3,3333 * 0.0001 )/( 1,38 * 3 );
    }

//-----------------------------------------------------------------------------

void CManager::CPressure ()
    {
    // P = 1/3*n*m*v^2 = 1/3*m*(mu*Na)*v^2/V

    double Volume0 = 100;

    Volume = Volume0 * (((100*PERY) - PistonYD)/(100*PERY));

    Pressure = (1/3)*3.3333*0.0001*6.023*1.00794*AverageVelocitySquared()/Volume;
    printf ( "%f\n", Pressure );
    }



//-----------------------------------------------------------------------------

void CManager::VesselAndPiston ()
    {
    txSetColor ( AllColor, 5 );

    txRectangle ( LWX, LWY, RWX, RWY );

    PistonYD = PistonYU + PistonWidth;

    if ( GAKS ( VK_UP )   && PistonYU > LWY ) PistonYU -= 2;
    if ( GAKS ( VK_DOWN ) && PistonYD < RWY ) PistonYU += 2;

    txRectangle ( LWX, PistonYU, RWX, PistonYD );
    }

//-----------------------------------------------------------------------------

void CManager::Table ()
    {
    txSelectFont ( "Arial", PERY*10 );

    for ( int i = 0; i < 7; i++ )
    txLine ( RWX, PERY*10*i, PERX*100, PERY*10*i );

    txLine ( (PERX*100 + RWX)/2, PERY*10, (PERX*100 + RWX)/2, PERY*60 );

    txDrawText ( RWX, 0, PERX*100, PERY*10, "THE IDEAL GASE" );

    txSelectFont ( "Arial", PERY*8 );

    txDrawText ( RWX, PERY*10, (PERX*100 + RWX)/2, PERY*20, "PHYSICAL VALUE" );

    txDrawText ( RWX, PERY*20, (PERX*100 + RWX)/2, PERY*30, "MOL. NUMBER" );
    txDrawText ( RWX, PERY*30, (PERX*100 + RWX)/2, PERY*40, "TEMPERATURE" );
    txDrawText ( RWX, PERY*40, (PERX*100 + RWX)/2, PERY*50, "VOLUME" );
    txDrawText ( RWX, PERY*50, (PERX*100 + RWX)/2, PERY*60, "PRESSURE" );

    txDrawText ( (PERX*100 + RWX)/2, PERY*10, PERX*100, PERY*20, "MAGNITUDE" );

    char Number[6] = "";
    itoa ( MomentSize, Number, 10 );
    txDrawText ( (PERX*100 + RWX)/2, PERY*20, PERX*100, PERY*30, Number );

    char TemperatureStr[6] = "";
    int  RTemperature = ROUND ( Temperature );
    itoa ( RTemperature, TemperatureStr, 10 );
    txDrawText ( (PERX*100 + RWX)/2, PERY*30, PERX*100, PERY*40, TemperatureStr );

    char VolumeStr[6] = "";
    int  RVolume = ROUND ( Volume );
    itoa ( RVolume, VolumeStr, 10 );
    txDrawText ( (PERX*100 + RWX)/2, PERY*40, PERX*100, PERY*50, VolumeStr );

    char PressureStr[6] = "";
    int  RPressure = ROUND ( Pressure );
    itoa ( RPressure, PressureStr, 10 );
    txDrawText ( (PERX*100 + RWX)/2, PERY*50, PERX*100, PERY*60, PressureStr );
    }

//-----------------------------------------------------------------------------

void CManager::SizePlus ()
    {
    if ( MomentSize <=  Size ) MomentSize++;
    }

//-----------------------------------------------------------------------------

void CManager::SizeMinus ()
    {
    if ( MomentSize >= 0 ) MomentSize--;
    }

//{----------------------------------------------------------------------------
//! OTHER ACTIONS
//}----------------------------------------------------------------------------

//-----------------------------------------------------------------------------

double Random ( double min, int max )
    {
    double ran = min + rand()%max;

    return ran;
    }

//-----------------------------------------------------------------------------
